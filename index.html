<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="PixelTime : A minimal weather clock that is easy to make" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>PixelTime</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/2dom/PixelTime">View on GitHub</a>

          <h1 id="project_title">PixelTime</h1>
          <h2 id="project_tagline">A minimal weather clock that is easy to make</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/2dom/PixelTime/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/2dom/PixelTime/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>Hacking</h2>

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/PixelTime_small.jpg" alt="">
Most hackers are driven by the quest for the perfect hack. A product of elegance, sometimes useful, simple in nature and yet high in impact.
In my humble opinion, a good hack should also be high in visual appeal, be low in cost, manual labour and materials and most importantly should not be too time consuming to repeat whilst requiring little skill to do so.
<br>
<br>
By this definition, I believe that PixelTime is my first project that comes anywhere close to being a perfect hack: it is useful (I also call it the “how to dress the kid’s device”), it is mindboggling easy to make (no soldering or other specialist skills required), looks fantastic, is extremely repeatable (very little manual labour required), costs about 40 EUR and takes about 30 minutes to assemble (+ optional case).


<h2>Display</h2>

When I started looking into making a weather clock for my family I naturally started with the central element - the display. Choosing the right display for a project is increasingly difficult since there are so many options! E-Paper, COG LCD, TFT, scanning laser, POV, glow-in-the-dark paper, WS2812B matrix, ferrofluid – you name it. Also, the choice of display defines to some extend the system that drives it. High resolution color varieties require high bus speeds, more memory and processing power. This is less of a problem cost-wise since the availability of the Raspberry Pis Zero, however, then we add the extra complexity of a full blown Linux system. This will reduce simplicity and repeatability significantly whilst increasing the involved time effort.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/P10_matrix.jpg" alt="">

In order to keep the complexity on the controller part to a minimum I settled on a ESP8266 based NodeMCU that comes with pre-soldered pin headers. On the display side of things, I chose a Chinese P10 RGB led matrix module that integrates all the necessary driver electronics into a single piece of kit. It offers 32x16=512 RGB pixels with a 1cm spacing for as little as 17 EUR.  The equivalent with WS2812B leds would cost at least twice as much. Furthermore, the P10 module comes fully assembled in a sturdy plastic module frame with defined screw mounts and offers connectivity via two standard pin-headers. Unfortunately, no driver for the ESP8266 existed so I had to write one. The <a href="https://github.com/2dom/P10_matrix">P10_matrix library</a> driver is Arduino GFX compatible so you can use all the standard graphics primitives and fonts. This picture shows the library in the early stages.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0617.jpg" alt="">

<h2>Diffuser and assembly</h2>

In order do obtain that vintage computer pixel look, I created a <a href="https://www.thingiverse.com/thing:2668845">16x16 separator grid</a>, printed two on my 3d printer and glued them together to form one big 32x16 mesh.
To obtain evenly lit pixels I used a sheet of A3 copy paper as a diffuser screen. As the front “glass” I got a piece of 3mm black/transparent acrylic for 10 EUR. For the back, I screwed a another piece of acrylic to the back of the matrix module using the standard screw mounts.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0621.jpg" alt="">

If we put all these parts together we end up with something rather nice: all electrical connections are made using standard Dupont style jumper cables, the module frame, the separator grid and the paper are simply sandwiched between the two pieces of acrylic being screwed together using a few longish M3 screws.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0827.jpg" alt="">
<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0829.jpg" alt="">

  If you have access to a laser cutter for the acrylic, you might get away without any box whatsoever. In my case, I had an old slatted bed-frame lying around that wanted to be used. So after some sawing, gluing and a few layers of Mahogany oil I had a nice box that fits our furniture in style.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0818.jpg" alt="">

  In order to supply and program PixelTime, I created a <a href="https://www.thingiverse.com/thing:2665294">NodeMCU panel mount</a>. Add a 2A phone charger and a nice 2m USB cable from ebay and voila – PixelTime it is.

<p><img src="https://raw.github.com/2dom/PixelTime/master/images/IMG_0821.jpg" alt="">

<h2>Software</h2>

In order for the software to run you will need to open an account with <a href="https://openweathermap.org/">openweathermap</a> (is free), edit the Wifi network credentials and update the REST request strings with your openweathermap API key and location. Apart from that, you should just be able to flash NodeMCU with the code as is. Flashing the NodeMCU requires  <a href="https://www.arduino.cc/en/Main/Software">Arduino</a> and the <a href="https://github.com/esp8266/Arduino">ESP8266 Arduino core</a>.
<br><br>
The display currently shows the temperature/weather of the current and next day. It jumps between minimum temperatures/worst weather and maximum temperatures/best weather in a 5 second interval.  I created some low resolution animated weather icons that are more or less compatible with the openweathermap rest responses. I just didn't bother  drawing all the night icons (who cares - it's dark).
<p><img src="https://raw.github.com/2dom/PixelTime/master/images/pixel_weather.gif" alt="">




<h2>Bill of materials</h2>

<p>Prices include delivery</p>

<ul>
<li>1x P10 LED Matrix (Aliexpress) – 17 EUR</li>
<li>20x Dupond jumper cables (Aliexpress) – 0.5 EUR</li>
<li>1x NodeMCU ESP8266 – 3 EUR</li>
<li>2x Acrylics – 10 EUR</li>
<li>1x 3D prints – 3 EUR (plastics)</li>
<li>1x 2A USB charger and 2m cable (ebay) – 8 EUR</li>
<li>10x M3x50mm screws and nuts – 2 EUR</li>
<li>1x Box – Free</li>
<li><strong>TOTAL: 43 EUR</strong></li>
</ul>


<p><img src="https://raw.github.com/2dom/PixelTime/master/images/PixelTime_animated.GIF" alt="">
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">PixelTime is maintained by <a href="https://github.com/2dom">2dom</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>



  </body>
</html>
